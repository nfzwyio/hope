import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,e as i,a as l,f as r,r as e,o as h,b as d}from"./app-DdYQHDMb.js";const p={};function g(k,s){const t=e("center");return h(),a("div",null,[s[1]||(s[1]=i(`<h1 id="第9章-库概览" tabindex="-1"><a class="header-anchor" href="#第9章-库概览"><span>第9章 库概览</span></a></h1><p>• 简介</p><p>• 标准库组件</p><p>• 标准库组织</p><p>​ 命名空间；</p><p>​ <strong>ranges</strong> 命名空间；</p><p>​ 模块；</p><p>​ 头文件</p><p>• 建议</p><h2 id="_9-1-简介" tabindex="-1"><a class="header-anchor" href="#_9-1-简介"><span>9.1 简介</span></a></h2><p>没有任何重要的程序是仅用裸编程语言编写的。首先，会开发一套库。这些库随后成为进一步工作的基础。大多数程序用裸语言编写都是繁琐的，而通过使用优秀的库，几乎任何任务都可以变得简单。</p><p>继第1至第8章之后，第9至第18章快速概述了关键标准库设施。我将简要介绍有用的标准库类型，如 <strong>string</strong> 、 <strong>ostream</strong> 、 <strong>variant</strong> 、 <strong>vector</strong> 、 <strong>map</strong> 、 <strong>path</strong> 、 <strong>unique_ptr</strong> 、 <strong>thread</strong> 、 <strong>regex</strong> 、 <strong>system_clock</strong> 、 <strong>time_zone</strong> 和 <strong>complex</strong> ，以及使用它们最常见的方法。</p><p>与第1至第8章一样，强烈建议您不要因对细节理解不全而分心或气馁。本章的目的是传达对最有用的库设施的基本理解。</p><p>标准库的规范占ISO C++标准的三分之二以上。探索它，并优先于自制的替代方案。在其设计上已经投入了大量的思考，其实施上更是如此，而且维护和扩展也将需要大量的努力。</p><p>本书中描述的标准库设施是每个完整的C++实现的一部分。除了标准库组件之外，大多数实现还提供“图形用户界面”系统(GUI)、Web接口、数据库接口等。类似地，大多数应用程序开发环境为公司或工业的“标准”开发和/或执行环境提供“基础库”。除此之外，还有数千个支持特定应用领域的库。在这里，我不会描述超出标准库之外的库、系统或环境。目的是提供一个由其标准[C++,2020]定义的C++自包含描述，并保持示例的可移植性。自然，鼓励程序员探索大多数系统上可用的更广泛设施。</p><h2 id="_9-2-设施" tabindex="-1"><a class="header-anchor" href="#_9-2-设施"><span>9.2 设施</span></a></h2><p>标准库提供的设施可以这样分类：</p><ul><li>运行时语言支持（例如，用于分配、异常和运行时类型信息）。</li><li>C标准库（进行了很小的修改以最小化类型系统违规）。</li><li>支持国际化字符集、本地化及子字符串的只读视图的字符串处理（§10.2）。</li><li>正则表达式匹配的支持（§10.4）。</li><li>输入输出流是一个可扩展框架，用户可以向其中添加自己的类型、流、缓冲策略、区域设置和字符集（第11章）。它还提供了灵活的输出格式化功能（§11.6.2）。</li><li>一个用于以可移植方式操作文件系统的库（§11.9）。</li><li>容器（如 <strong>vector</strong> 和 <strong>map</strong> ；第12章）和算法（如 <strong>find()</strong> 、 <strong>sort()</strong> 和 <strong>merge()</strong> ；第13章）的框架。这个传统上称为 <strong>STL</strong> 的框架[Stepanov,1994]是可扩展的，因此用户可以添加自己的容器和算法。</li><li>范围（§14.1），包括视图（§14.2）、生成器（§14.3）和管道（§14.4）。</li><li>基本类型和范围的概念（§14.5）。</li><li>对数值计算的支持，如标准数学函数、复数、具有算术运算的向量、数学常数和随机数生成器（§5.2.1和第16章）。</li><li>对并发编程的支持，包括 <strong>线程</strong> 和 <strong>锁</strong> （第18章）。并发支持是基础性的，以便用户能够以库的形式添加对新并发模型的支持。</li><li>同步和异步协程（§18.6）。</li><li>大部分 <strong>STL</strong> 算法和一些数值算法（如 <strong>sort()</strong> （§13.6）和 <strong>reduce()</strong> （§17.3.1））的并行版本。</li><li>支持元编程（例如，类型函数；§16.4）、STL风格的泛型编程（例如， <strong>pair</strong> ；§15.3.3）和一般编程（例如， <strong>variant</strong> 和 <strong>optional</strong> ；§15.4.1, §15.4.2）的实用工具。</li><li>用于资源管理的“智能指针”（如 <strong>unique_ptr</strong> 和 <strong>shared_ptr</strong> ；§15.2.1）。</li><li>特殊用途容器，如 <strong>array</strong> （§15.3.1）、 <strong>bitset</strong> （§15.3.2）和 <strong>tuple</strong> （§15.3.3）。</li><li>支持绝对时间和持续时间，如 <strong>time_point</strong> 和 <strong>system_clock</strong> （§16.2.1）。</li><li>支持日历，如 <strong>month</strong> 和 <strong>time_zone</strong> （§16.2.2, §16.2.3）。</li><li>流行单位的后缀，如 <strong>ms</strong> 表示毫秒， <strong>i</strong> 表示虚部（§6.6）。</li><li>操纵元素序列的方法，如视图（§14.2）、 <strong>string_views</strong> （§10.3）和 <strong>spans</strong> （§15.2.2）。将一个类包含进库的主要标准是： <ul><li>它几乎可以帮助每一位C++程序员（无论新手还是专家）。</li><li>它可以以一种通用的形式提供，相比同一设施的简化版本，不会增加显著的开销。</li><li>简单的使用应该易于学习（相对于他们任务固有的复杂度）。</li></ul></li></ul><p>实质上，C++标准库提供了最常见且基础的数据结构，以及在这些数据结构上使用的根本算法。</p><h2 id="_9-3-标准库组织结构" tabindex="-1"><a class="header-anchor" href="#_9-3-标准库组织结构"><span>9.3 标准库组织结构</span></a></h2><p>标准库的所有设施都被放置在名为 <strong>std</strong> 的命名空间中，并通过模块或头文件向用户开放。</p><h3 id="_9-3-1-命名空间" tabindex="-1"><a class="header-anchor" href="#_9-3-1-命名空间"><span>9.3.1 命名空间</span></a></h3><p>每个标准库设施都是通过某个标准头文件提供的。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;string&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;list&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这使得标准的 <strong>string</strong> 和 <strong>list</strong> 可用。</p><p>标准库是在名为 <strong>std</strong> 的命名空间（§3.3）中定义的。要使用标准库设施，可以使用 <strong>std::</strong> 前缀：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string sheep {</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Four legs Good; two legs Baaad!&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::list</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">std::string</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> slogans {</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;War is Peace&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Freedom is Slavery&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Ignorance is Strength&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>为了简洁，在示例中我很少使用 <strong>std::</strong> 前缀。我也不会明确地 <strong>#include</strong> 或 <strong>import</strong> 必要的头文件或模块。要编译和运行这里的程序片段，你必须使标准库的相关部分可用。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">#include</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &lt;string&gt;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 使标准字符串设施可访问</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 使std中的名字无需std::前缀即可使用</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">string s {</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;C++ is a general-purpose programming language&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 可行：string等同于std::string</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通常情况下，将命名空间中的所有名字导入全局命名空间是不推荐的做法。然而，在本书中，我专一使用标准库，了解它提供的内容是有益的。</p><p>标准库向 <strong>std</strong> 提供了几个只能通过显式动作访问的子命名空间：</p><ul><li><strong>std::chrono</strong> ：chrono中的所有设施，包括 <strong>std::literals::chrono_literals</strong> （§16.2）。</li><li><strong>std::literals::chrono_literals</strong> ：年份的 <strong>y</strong> 、天数的 <strong>d</strong> 、小时的 <strong>h</strong> 、分钟的 <strong>min</strong> 、毫秒的 <strong>ms</strong> 、纳秒的 <strong>ns</strong> 、秒的 <strong>s</strong> 以及微秒的 <strong>us</strong> 后缀（§16.2）。</li><li><strong>std::literals::complex_literals</strong> ：虚部double的 <strong>i</strong> 、虚部float的 <strong>if</strong> 和虚部long double的 <strong>il</strong> 后缀（§6.6）。</li><li><strong>std::literals::string_literals</strong> ：字符串的 <strong>s</strong> 后缀（§6.6, §10.2）。</li><li><strong>std::literals::string_view_literals</strong> ：字符串视图的 <strong>sv</strong> 后缀（§10.3）。</li><li><strong>std::numbers</strong> ：数学常数（§17.9）。</li><li><strong>std::pmr</strong> ：多态内存资源(polymorphic memory resources)（§12.7）。</li></ul><p>要使用子命名空间中的后缀，我们必须将其引入我们想要使用它的命名空间中。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 未提及complex_literals</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> z1 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 错误：没有&#39;i&#39;后缀</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> literals::</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">complex_literals</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 使复数字面量可见</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">auto</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> z2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 2</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">+</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">3</span><span style="--shiki-light:#986801;--shiki-dark:#E06C75;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 正确：z2是一个complex&lt;double&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于什么应该放在子命名空间中，并没有一致的哲学。但是，后缀不能被明确限定，所以我们只能引入一组后缀到一个作用域中，以防引起歧义。因此，为打算与其他可能定义自己后缀的库一起工作的库设计的后缀，会被放置在子命名空间中。</p><h3 id="_9-3-2-ranges命名空间" tabindex="-1"><a class="header-anchor" href="#_9-3-2-ranges命名空间"><span>9.3.2 ranges命名空间</span></a></h3><p>标准库提供了两种版本的算法，比如 <strong>sort()</strong> 和 <strong>copy()</strong> ：</p><ul><li>传统的序列版本，接受一对迭代器；例如， <strong>sort(begin(v),v.end())</strong></li><li>范围版本，接受单一范围；例如， <strong>sort(v)</strong></li></ul><p>理想情况下，这两个版本应能完美重载，无需特殊努力。然而，事实并非如此。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> ranges</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">vector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">begin</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">end</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 错误：二义性</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                     // 错误：二义性</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了避免在使用传统无约束模板时产生的二义性，标准要求我们显式地将标准库算法的范围版本引入作用域：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">using</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> namespace</span><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;"> std</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> g</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">vector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">begin</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">end</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">());</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">       //  OK</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                        //  error: no matching function (in std)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    ranges::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                //  OK</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    using</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ranges::sort;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">             // 从这里开始，sort(v)就正确了</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    sort</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">                        // OK</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过这种方式，我们能够明确区分并正确调用传统迭代器版本和范围版本的算法。</p><h3 id="_9-3-3-模块" tabindex="-1"><a class="header-anchor" href="#_9-3-3-模块"><span>9.3.3 模块</span></a></h3><p>目前还没有标准库模块。C++23很可能会弥补这一遗漏（这是由于委员会时间不足造成的）。目前，我使用的模块名为 <strong>std</strong> ，这很可能会成为标准，它提供了 <strong>std</strong> 命名空间中的所有设施。详情参见附录A。</p><h3 id="_9-3-4-头文件" tabindex="-1"><a class="header-anchor" href="#_9-3-4-头文件"><span>9.3.4 头文件</span></a></h3><p>以下是一些标准库头文件的选摘，它们都在 <strong>std</strong> 命名空间中提供声明：</p>`,47)),l(t,null,{default:r(()=>s[0]||(s[0]=[d("strong",null,"选定的标准库头文件",-1)])),_:1}),s[2]||(s[2]=i('<table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>&lt;algorithm&gt;</td><td>copy(), find(), sort()</td><td>Chapter 13</td></tr><tr><td>&lt;array&gt;</td><td>array</td><td>§15.3.1</td></tr><tr><td>&lt;chrono&gt;</td><td>duration, time_point, month, time_zone</td><td>§16.2</td></tr><tr><td>&lt;cmath&gt;</td><td>sqrt(), pow()</td><td>§17.2</td></tr><tr><td>&lt;complex&gt;</td><td>complex, sqrt(), pow()</td><td>§17.4</td></tr><tr><td>&lt;concepts&gt;</td><td>floating_point, copyable, predicate, invocable</td><td>§14.5</td></tr><tr><td>&lt;filesystem&gt;</td><td>path</td><td>§11.9</td></tr><tr><td>&lt;format&gt;</td><td>format()</td><td>§11.6.2</td></tr><tr><td>&lt;fstream&gt;</td><td>fstream, ifstream, ofstream</td><td>§11.7.2</td></tr><tr><td>&lt;functional&gt;</td><td>function, greater_equal, hash, range_value_t</td><td>Chapter 16</td></tr><tr><td>&lt;future&gt;</td><td>future, promise</td><td>§18.5</td></tr><tr><td>&lt;ios&gt;</td><td>hex, dec, scientific, fixed, defaultfloat</td><td>§11.6.2</td></tr><tr><td>&lt;iostream&gt;</td><td>istream, ostream, cin, cout</td><td>Chapter 11</td></tr><tr><td>&lt;map&gt;</td><td>map, multimap</td><td>§12.6</td></tr><tr><td>&lt;memory&gt;</td><td>unique_ptr, shared_ptr, allocator</td><td>§15.2.1</td></tr><tr><td>&lt;random&gt;</td><td>default_random_engine, normal_distribution</td><td>§17.5</td></tr><tr><td>&lt;ranges&gt;</td><td>sized_range, subrange, take(), split(), iterator_t</td><td>§14.1</td></tr><tr><td>&lt;regex&gt;</td><td>regex, smatch</td><td>§10.4</td></tr><tr><td>&lt;string&gt;</td><td>string, basic_string</td><td>§10.2</td></tr><tr><td>&lt;string_view&gt;</td><td>string_view</td><td>§10.3</td></tr><tr><td>&lt;set&gt;</td><td>set, multiset</td><td>§12.8</td></tr><tr><td>&lt;sstream&gt;</td><td>istringstream, ostringstream</td><td>§11.7.3</td></tr><tr><td>&lt;stdexcept&gt;</td><td>length_error, out_of_range, runtime_error</td><td>§4.2</td></tr><tr><td>&lt;tuple&gt;</td><td>tuple, get&lt;&gt;(), tuple_size&lt;&gt;</td><td>§15.3.4</td></tr><tr><td>&lt;thread&gt;</td><td>thread</td><td>§18.2</td></tr><tr><td>&lt;unordered_map&gt;</td><td>unordered_map, unordered_multimap</td><td>§12.6</td></tr><tr><td>&lt;utility&gt;</td><td>move(), swap(), pair</td><td>Chapter 16</td></tr><tr><td>&lt;variant&gt;</td><td>variant</td><td>§15.4.1</td></tr><tr><td>&lt;vector&gt;</td><td>vector</td><td>§12.2</td></tr></tbody></table><p>该列表远未完成。</p><p>C标准库中的头文件，例如 <strong>&lt;stdlib.h&gt;</strong> ，都会提供。对于每个这样的头文件，都存在一个版本，其名称以前缀 <strong>c</strong> 开头并去掉了 <strong>.h</strong> 。这样的版本，比如 <strong>&lt;cstdlib&gt;</strong> ，会将其声明放在 <strong>std</strong> 和全局命名空间中。</p><p>这些头文件反映了标准库开发的历史。因此，它们并不总是如我们所期望的那样逻辑清晰和易于记忆。这是使用模块（例如 <strong>std</strong> （§9.3.3））的一个原因。</p><h2 id="_9-4-建议" tabindex="-1"><a class="header-anchor" href="#_9-4-建议"><span>9.4 建议</span></a></h2><ol><li>不要重复造轮子；使用库；§9.1；[CG: SL.1.]</li><li>当有选择时，优先选择标准库而非其他库；§9.1；[CG: SL.2]。</li><li>不要认为标准库对所有事情都是最理想的；§9.1。</li><li>如果不使用模块，请记住 <strong>#include</strong> 相应的头文件；§9.3.1。</li><li>记住，标准库设施定义在 <strong>std</strong> 命名空间中；§9.3.1；[CG: SL.3]。</li><li>使用 <strong>ranges</strong> 时，请记住显式指定算法名称；§9.3.2。</li><li>优先导入模块而不是 <strong>#include</strong> 头文件（§9.3.3）。</li></ol>',6))])}const A=n(p,[["render",g],["__file","index.html.vue"]]),y=JSON.parse('{"path":"/cpp/chapter09/","title":"第9章 库概览","lang":"zh-CN","frontmatter":{"permalink":"/cpp/chapter09/"},"headers":[{"level":2,"title":"9.1 简介","slug":"_9-1-简介","link":"#_9-1-简介","children":[]},{"level":2,"title":"9.2 设施","slug":"_9-2-设施","link":"#_9-2-设施","children":[]},{"level":2,"title":"9.3 标准库组织结构","slug":"_9-3-标准库组织结构","link":"#_9-3-标准库组织结构","children":[{"level":3,"title":"9.3.1 命名空间","slug":"_9-3-1-命名空间","link":"#_9-3-1-命名空间","children":[]},{"level":3,"title":"9.3.2 ranges命名空间","slug":"_9-3-2-ranges命名空间","link":"#_9-3-2-ranges命名空间","children":[]},{"level":3,"title":"9.3.3 模块","slug":"_9-3-3-模块","link":"#_9-3-3-模块","children":[]},{"level":3,"title":"9.3.4 头文件","slug":"_9-3-4-头文件","link":"#_9-3-4-头文件","children":[]}]},{"level":2,"title":"9.4 建议","slug":"_9-4-建议","link":"#_9-4-建议","children":[]}],"git":{"createdTime":1729937676000,"updatedTime":1730025137000,"contributors":[{"name":"nfzwy","email":"nfzwy@南风","commits":2}]},"readingTime":{"minutes":8.54,"words":2563},"filePathRelative":"a tour of c++/第9章 库概览.md","localizedDate":"2024年10月26日","excerpt":"\\n<p>• 简介</p>\\n<p>• 标准库组件</p>\\n<p>• 标准库组织</p>\\n<p>​\\t命名空间；</p>\\n<p>​ <strong>ranges</strong> 命名空间；</p>\\n<p>​\\t模块；</p>\\n<p>​\\t头文件</p>\\n<p>• 建议</p>\\n<h2>9.1 简介</h2>\\n<p>没有任何重要的程序是仅用裸编程语言编写的。首先，会开发一套库。这些库随后成为进一步工作的基础。大多数程序用裸语言编写都是繁琐的，而通过使用优秀的库，几乎任何任务都可以变得简单。</p>\\n<p>继第1至第8章之后，第9至第18章快速概述了关键标准库设施。我将简要介绍有用的标准库类型，如 <strong>string</strong> 、 <strong>ostream</strong> 、 <strong>variant</strong> 、 <strong>vector</strong> 、 <strong>map</strong> 、 <strong>path</strong> 、 <strong>unique_ptr</strong> 、 <strong>thread</strong> 、 <strong>regex</strong> 、 <strong>system_clock</strong> 、 <strong>time_zone</strong> 和 <strong>complex</strong> ，以及使用它们最常见的方法。</p>"}');export{A as comp,y as data};
