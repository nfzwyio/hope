<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.18" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.59" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://blog.nfzwy.com/cpp/chapter04/"><meta property="og:site_name" content="南风文档"><meta property="og:title" content="第4章 错误处理"><meta property="og:description" content="第4章 错误处理 简介 异常 不变性 错误处理的替代方案 断言 assert() static_assert noexcept 建议 4.1 简介 错误处理是一个庞大且复杂的话题，其关注点和影响远远超出了语言设施本身，触及编程技术和工具等多个层面。然而，C++ 提供了一些特性来辅助这一过程。最重要的工具就是类型系统本身。我们不再繁琐地仅从基本类型（如 ..."><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-11-08T04:35:03.000Z"><meta property="article:modified_time" content="2024-11-08T04:35:03.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"第4章 错误处理","image":[""],"dateModified":"2024-11-08T04:35:03.000Z","author":[{"@type":"Person","name":"南风","url":"https://blog.nfwzy.com"}]}</script><link rel="icon" href="/favicon.ico"><link rel="icon" href="/assets/icon/chrome-mask-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/assets/icon/chrome-mask-192.png" type="image/png" sizes="192x192"><link rel="icon" href="/assets/icon/chrome-512.png" type="image/png" sizes="512x512"><link rel="icon" href="/assets/icon/chrome-192.png" type="image/png" sizes="192x192"><link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#46bd87"><link rel="apple-touch-icon" href="/assets/icon/apple-icon-152.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="msapplication-TileImage" content="/assets/icon/ms-icon-144.png"><meta name="msapplication-TileColor" content="#ffffff"><title>第4章 错误处理 | 南风文档</title><meta name="description" content="第4章 错误处理 简介 异常 不变性 错误处理的替代方案 断言 assert() static_assert noexcept 建议 4.1 简介 错误处理是一个庞大且复杂的话题，其关注点和影响远远超出了语言设施本身，触及编程技术和工具等多个层面。然而，C++ 提供了一些特性来辅助这一过程。最重要的工具就是类型系统本身。我们不再繁琐地仅从基本类型（如 ...">
    <link rel="preload" href="/assets/style-D8TpGQTN.css" as="style"><link rel="stylesheet" href="/assets/style-D8TpGQTN.css">
    <link rel="modulepreload" href="/assets/app-tSwHPRi-.js"><link rel="modulepreload" href="/assets/index.html-CmBRzWJA.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><!--[--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/" aria-label="带我回家"><img class="vp-nav-logo" src="/logo.ico" alt><!----><span class="vp-site-name hide-in-pad">南风文档</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="南风文档"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span><!--]-->南风文档<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/js/chapter03/" aria-label="Javascript"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><!--]-->Javascript<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/cptnet/chapter01/" aria-label="计算机网络"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><!--]-->计算机网络<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/cpp/chapter00/" aria-label="C++之旅"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><!--]-->C++之旅<!----></a></div></nav><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><!----><!----><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><p class="vp-sidebar-header active"><span class="font-icon icon fa-fw fa-sm fas fa-book" style=""></span><span class="vp-sidebar-title">C++之旅</span><!----></p><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter00/" aria-label="开始"><!---->开始<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter01/" aria-label="基础"><!---->基础<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter02/" aria-label="第2章 用户定义类型"><!---->第2章 用户定义类型<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter03/" aria-label="第3章 模块化"><!---->第3章 模块化<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/cpp/chapter04/" aria-label="第4章 错误处理"><!---->第4章 错误处理<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter05/" aria-label="第5章 类"><!---->第5章 类<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter06/" aria-label="第6章 基本操作"><!---->第6章 基本操作<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter07/" aria-label="第7章 模板"><!---->第7章 模板<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter08/" aria-label="第8章 概念与泛型编程"><!---->第8章 概念与泛型编程<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter09/" aria-label="第9章 库概览"><!---->第9章 库概览<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter10/" aria-label="第10章 字符串和正则表达式"><!---->第10章 字符串和正则表达式<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter11/" aria-label="第11章 输入输出"><!---->第11章 输入输出<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter12/" aria-label="第12章 容器"><!---->第12章 容器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter13/" aria-label="第13章 算法"><!---->第13章 算法<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter14/" aria-label="第14章 Ranges"><!---->第14章 Ranges<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter15/" aria-label="第15章 指针和容器"><!---->第15章 指针和容器<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter16/" aria-label="第16章 实用工具"><!---->第16章 实用工具<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter17/" aria-label="第17章  数值"><!---->第17章  数值<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter18/" aria-label="第18章 并发"><!---->第18章 并发<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter19/" aria-label="第19章 历史与兼容性"><!---->第19章 历史与兼容性<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/cpp/chapter20/" aria-label="第20章 std模块"><!---->第20章 std模块<!----></a></li></ul></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->第4章 错误处理</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://blog.nfwzy.com" target="_blank" rel="noopener noreferrer">南风</a></span><span property="author" content="南风"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">2024年10月26日</span><meta property="datePublished" content="2024-10-26T10:14:36.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 19 分钟</span><meta property="timeRequired" content="PT19M"></span><!----><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc" vp-toc><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_4-1-简介">4.1 简介</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_4-2-异常处理">4.2 异常处理</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_4-3-约束条件">4.3 约束条件</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_4-4-错误处理的其他选择">4.4 错误处理的其他选择</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_4-5-断言">4.5 断言</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-5-1-assert-函数">4.5.1 assert() 函数</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-5-2-静态断言">4.5.2 静态断言</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#_4-5-3-noexcept">4.5.3 noexcept</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#_4-6-建议">4.6 建议</a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content" vp-content><h1 id="第4章-错误处理" tabindex="-1"><a class="header-anchor" href="#第4章-错误处理"><span>第4章 错误处理</span></a></h1><ul><li><p>简介</p></li><li><p>异常</p></li><li><p>不变性</p></li><li><p>错误处理的替代方案</p></li><li><p>断言</p><ul><li><strong>assert()</strong></li><li><strong>static_assert</strong></li><li><strong>noexcept</strong></li></ul></li><li><p>建议</p></li></ul><h2 id="_4-1-简介" tabindex="-1"><a class="header-anchor" href="#_4-1-简介"><span>4.1 简介</span></a></h2><p>错误处理是一个庞大且复杂的话题，其关注点和影响远远超出了语言设施本身，触及编程技术和工具等多个层面。然而，C++ 提供了一些特性来辅助这一过程。最重要的工具就是类型系统本身。我们不再繁琐地仅从基本类型（如 <strong>char</strong> 、 <strong>int</strong> 和 <strong>double</strong> ）及语句（如 <strong>if</strong> 、 <strong>while</strong> 和 <strong>for</strong> ）构建应用程序，而是构建适用于我们应用的类型（如 <strong>string</strong> 、 <strong>map</strong> 和 <strong>thread</strong> ）和算法（如 <strong>sort()</strong> 、 <strong>find_if()</strong> 和 <strong>draw_all()</strong> ）。</p><p>这些更高级别的构造简化了我们的编程，限制了出错的可能性（例如，你不太可能尝试对一个对话框应用树遍历），并增加了编译器捕获错误的机会。C++ 语言中的大多数结构都是致力于设计和实现优雅且高效的抽象（如用户自定义类型及其使用的算法）。使用这些抽象的一个效果是，运行时错误能够被检测到的点与能够处理该错误的点被分离开来。随着程序规模的增长，尤其是在大量使用库时，错误处理的标准变得尤为重要。在程序开发的早期明确一套错误处理策略是个好主意。</p><h2 id="_4-2-异常处理" tabindex="-1"><a class="header-anchor" href="#_4-2-异常处理"><span>4.2 异常处理</span></a></h2><p>让我们再次回顾 <strong>Vector</strong> 类的例子。当我们试图访问一个超出§ 2.3中 <strong>Vector</strong> 容量范围的元素时，应该如何处理？</p><ul><li><strong>Vector</strong> 的编写者不知道用户希望在这种情况下怎么做（实际上， <strong>Vector</strong> 的编写者通常甚至不知道 <strong>Vector</strong> 将在哪一个程序中运行）。</li><li><strong>Vector</strong> 的使用者无法一致地检测到这个问题（如果使用者能够检测到，就不会发生越界访问了）。</li></ul><p>假设我们希望从越界访问这种错误中恢复，解决方案是让 <strong>Vector</strong> 的实现者检测到尝试越界访问的行为，并告知用户这一情况。然后，用户可以采取适当的行动。例如， <strong>Vector::operator[]()</strong> 可以检测到尝试的越界访问，并抛出一个 <strong>out_of_range</strong> 异常：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">double&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Vector::</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[](</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">())) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        throw</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> out_of_range{</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Vector::operator[]&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> elem</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的 <strong>throw</strong> 会将控制权转移给直接或间接调用了 <strong>Vector::operator[]()</strong> 的某个函数中的 <strong>out_of_range</strong> 类型异常处理器。为此，实现会按需 <strong>回溯</strong> 函数调用栈，直到回到对该异常类型感兴趣的调用者的上下文中。也就是说，异常处理机制会在必要时退出作用域和函数，直至到达一个表达了处理该类型异常意愿的调用者，并沿途按需调用析构函数（§ 5.2.2）。</p><p>例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Vector</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&amp;</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 在这个块内抛出的 out_of_range 异常由下面定义的处理器处理</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        compute1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 可能尝试访问 v 的末端之外</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        Vector v2 </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> compute2</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 可能尝试访问 v 的末端之外</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">        compute3</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(v2);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 可能尝试访问 v2 的末端之外</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> out_of_range</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> err) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 哎呀：发生了 out_of_range 错误</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ... 处理范围错误 ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        cerr </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> err</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">what</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们将感兴趣的异常处理代码放入 <strong>try</strong> 块中。 <strong>compute1()</strong> 、 <strong>compute2()</strong> 和 <strong>compute3()</strong> 的调用代表了一组代码，我们无法简单地预先判断是否会发生范围错误。通过 <strong>catch</strong> 子句，我们提供了处理 <strong>out_of_range</strong> 类型异常的机制。如果 <strong>f()</strong> 不是处理这类异常的好地方，我们就不会使用 <strong>try</strong> 块，而是让异常隐式传递给 <strong>f()</strong> 的调用者。</p><p><strong>out_of_range</strong> 类型是在标准库中定义的（位于 <strong>&lt;stdexcept&gt;</strong> 中），并且实际上被一些标准库容器的访问函数所使用。</p><p>我通过引用捕获异常以避免复制，并使用了 <strong>what()</strong> 函数来打印在 <strong>抛出</strong> 点放入的错误消息。</p><p>使用异常处理机制可以使错误处理变得更加简单、系统化和可读性强。为了实现这一点，不要过度使用 <strong>try</strong> 语句。在许多程序中，从 <strong>抛出异常</strong> 到可以合理处理该异常的函数之间，通常会有数十个函数调用。因此，大多数函数应该简单地允许异常沿着调用堆栈传播。</p><p>使错误处理变得简单和系统化的主要技术（称为 <strong>资源获取即初始化</strong> ； <strong>RAII</strong> ）在 §5.2.2 中进行了解释。RAII背后的基本思想是让构造函数获取类操作所需的资源，并让析构函数释放所有资源，从而确保并隐式地完成资源释放。</p><h2 id="_4-3-约束条件" tabindex="-1"><a class="header-anchor" href="#_4-3-约束条件"><span>4.3 约束条件</span></a></h2><p>使用异常来指示越界访问是一种函数检查其参数并在基本假设（先决条件）未满足时拒绝执行的例子。如果我们正式地指定 <strong>Vector</strong> 的下标运算符，我们会说“索引必须在<a href=""><strong>0:size()</strong> )范围内”，这实际上也是我们在 **operator[</a>** 中进行测试的内容。[ <strong>a:b</strong> ) 符号指定一个半开区间，意味着 <strong>a</strong> 是区间的一部分，而 <strong>b</strong> 不是。每当我们定义一个函数时，我们都应考虑它的先决条件是什么，并考虑是否应该测试它们（§ 4.4）。对于大多数应用来说，测试简单的不变性是一个好主意；§ 4.5。</p><p>然而， <strong>operator[]()</strong> 操作 <strong>Vector</strong> 类型的对象，如果不满足“合理”值这一条件，它所做的任何事情都没有意义。特别是，我们确实说过“ <strong>elem</strong> 指向一个大小为 <strong>sz</strong> 的 <strong>double</strong> 数组”，但那只是在注释中提到的。对于类而言，关于其内部被认为始终为真的陈述被称为 <strong>类不变性</strong> ，或简称为 <strong>不变性</strong> 。构造函数的任务是为其类建立不变性（以便成员函数可以依赖这一点），而成员函数则需要确保在它们退出时不变性仍然成立。不幸的是，我们的 <strong>Vector</strong> 构造函数只部分完成了这项工作。它正确地初始化了 <strong>Vector</strong> 的成员，但未能检查传递给它的参数是否有意义。考虑以下情况：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Vector</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">27</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这很可能会导致混乱。</p><p>以下是更合适的定义：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E5C07B;">Vector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Vector</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (s </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        throw</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> std::length_error{</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;Vector constructor: negative size&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">};</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    elem </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> double</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[s];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    sz </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> s;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我使用标准库异常 <strong>length_error</strong> 来报告元素数量为负数的情况，因为某些标准库操作使用该异常来报告此类问题。如果 <strong>new</strong> 操作无法找到足够的内存来分配，则会抛出 <strong>std::bad_alloc</strong> 。现在我们可以这样写：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        Vector </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (std::length_error</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> err) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ... 处理负数 ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (std::bad_alloc</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> err) {</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">        // ... 处理内存耗尽 ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> run</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">-</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">27</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 抛出 length_error (-27 太小)</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1&#39;000&#39;000&#39;000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 可能抛出 bad_alloc</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">10</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">     // 很可能正常</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>内存耗尽发生在请求的内存超过机器提供的总量，或者程序已经几乎消耗了那么多，而你的请求使其超过了极限时。请注意，现代操作系统通常会给你比物理内存一次可容纳更多的空间，因此请求过多的内存可能会在触发 <strong>bad_alloc</strong> 之前很久就导致严重的性能下降。</p><p>你可以自定义类作为异常，并让它们携带从检测到错误的点到可以处理该错误的点所需的信息，无论多少（§ 4.2）。没有必要使用标准库异常层次结构。</p><p>通常，一旦抛出异常，函数就没有办法完成其指定任务。这时，“处理”异常意味着做一些最小限度的本地清理然后重新抛出异常。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> test</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> n</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    try</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        Vector </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(n);</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (std::length_error</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 做些处理然后重新抛出</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        std::cerr </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;test failed: length error</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        throw</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 重新抛出</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    } </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">catch</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (std::bad_alloc</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) {</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 哎呀！此程序未设计处理内存耗尽的情况</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">        std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">terminate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">  // 终止程序</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在设计良好的代码中， <strong>try</strong> 块是罕见的。通过系统地使用 RAII 技术（§ 5.2.2、§ 6.3）来避免过度使用。</p><p>不变性的概念对于类的设计至关重要，而在函数设计中，前置条件扮演着类似的角色：</p><ul><li>制定不变性有助于我们精确理解所需的目标。</li><li>不变性迫使我们具体化设计；这使我们的代码更有可能正确无误。</li></ul><p>不变性的概念支撑着 C++ 中由构造函数（第五章）和析构函数（§ 5.2.2、§ 15.2.1）支持的资源管理理念。</p><h2 id="_4-4-错误处理的其他选择" tabindex="-1"><a class="header-anchor" href="#_4-4-错误处理的其他选择"><span>4.4 错误处理的其他选择</span></a></h2><p>错误处理是所有现实世界软件中的重大问题，因此自然有多种方法可供选择。如果在一个函数中检测到错误，且该错误不能在该函数内部得到本地处理，那么该函数必须以某种方式将问题传达给调用者。抛出异常是 C++ 中用于此目的最通用的机制。</p><p>有些语言设计异常仅仅是为了提供一种返回值的替代机制，而C++并非如此设计：异常是用来报告特定任务失败的。异常与构造函数和析构函数相结合，为错误处理和资源管理提供了一个连贯的框架（§ 5.2.2、§ 6.3）。编译器优化使得返回一个值远比抛出相同值作为异常的成本要低。</p><p>抛出异常并不是报告无法本地处理错误的唯一方法。一个函数可以通过以下方式表明它无法执行分配的任务：</p><ul><li>抛出异常</li><li>以某种方式返回表示失败的值</li><li>终止程序（通过调用类似 <strong>terminate()</strong> 、 <strong>exit()</strong> 或 <strong>abort()</strong> 的函数；§ 16.8）</li></ul><p>我们返回错误指示符（即“错误码”）的情况包括：</p><ul><li>失败是正常且预期的。例如，尝试打开文件失败是很常见的（可能没有这个名字的文件，或者可能无法按照请求的权限打开文件）。</li><li>直接调用者可以合理地预期并处理失败。</li><li>在一组并行任务中发生错误，我们需要知道哪个任务失败了。</li><li>系统内存非常有限，以至于异常的运行时支持会挤占重要功能的空间。</li></ul><p>我们抛出异常的情况包括：</p><ul><li>错误极为罕见，程序员很可能忘记检查它。例如，你上一次检查 <strong>printf()</strong> 的返回值是什么时候？</li><li>错误不能由直接调用者处理。相反，错误需要向上回溯调用链，直至“最终调用者”。例如，让应用程序中的每个函数可靠地处理每次分配失败和网络中断是不切实际的。反复检查错误码既繁琐又昂贵，且容易出错。错误检查和作为返回值传递错误码的测试很容易掩盖函数的主要逻辑。</li><li>应用程序的低层模块可以添加新的错误类型，使得高层模块不需要编写代码来应对这些错误。例如，当一个原本单线程的应用程序修改为使用多线程，或资源被放置在网络中远程访问时。</li><li>没有适合的返回路径来传递错误码。例如，构造函数没有“调用者”可以检查的返回值。特别地，构造函数可能被用于多个局部变量或在复杂对象的部分构造过程中被调用，因此基于错误码的清理会相当复杂。同样，操作符通常也没有明显的返回路径来传递错误码，例如 <strong>a*b+c/d</strong> 。</li><li>函数的返回路径因需要同时传递值和错误指示符而变得更加复杂或成本更高（例如，使用 <strong>pair</strong> ；§ 15.3.3），这可能导致使用输出参数、非局部错误状态指示器或其他变通方法。</li><li>从多个函数调用中恢复错误取决于它们的结果，导致需要在调用之间维护局部状态以及复杂的控制结构。</li><li>发现错误的函数是一个回调（函数参数），因此直接调用者甚至可能不知道调用了什么函数。</li><li>错误暗示需要进行某种“撤销操作”（§ 5.2.2）。</li></ul><p>我们终止程序的情况包括：</p><ul><li>遇到无法从中恢复的错误类型。例如，对于许多（但不是全部）系统而言，没有合理的途径从内存耗尽中恢复。</li><li>系统基于在检测到非平凡错误时重启线程、进程或计算机来处理错误。</li></ul><p>确保终止的一种方法是在函数上添加 <strong>noexcept</strong> （§ 4.5.3），这样一来，函数实现中的任何地方抛出都会转化为 <strong>terminate()</strong> 。需要注意的是，有些应用程序不能接受无条件终止，因此必须使用其他替代方案。面向通用目的的库绝不应无条件终止。</p><p>不幸的是，这些条件并不总是逻辑上互斥且易于应用。程序的大小和复杂度很重要。有时，随着应用程序的发展，权衡也会发生变化。这需要经验。当有疑问时，倾向于使用异常，因为它们的使用更易于扩展，且不需要外部工具来检查所有错误是否都已处理。</p><p>不要认为所有的错误码或所有的异常都是不好的；两者都有明确的使用场景。此外，不要相信异常处理慢的误解；在正确处理复杂或罕见错误条件，以及重复测试错误码时，异常处理往往更快。</p><p>使用异常进行简单和高效错误处理的关键是 RAII（§ 5.2.2、§ 6.3）。遍布着 <strong>try</strong> 块的代码往往反映了为错误码设计的错误处理策略中最糟糕的方面。</p><h2 id="_4-5-断言" tabindex="-1"><a class="header-anchor" href="#_4-5-断言"><span>4.5 断言</span></a></h2><p>目前，没有通用且标准的方式来编写可选的运行时检查，比如不变性、前置条件等。然而，对于许多大型程序来说，存在这样的需求：支持用户在测试期间依赖广泛的运行时检查，但在部署代码时只进行最少的检查。</p><p>目前，我们必须依赖于特殊的机制。有许多这样的机制。它们需要具备灵活性、通用性，并且在不启用时不会产生任何成本。这意味着概念上的简洁性和实现上的复杂性。以下是我使用过的一个方案：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">enum</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Error_action</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">ignore</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">throwing</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">terminating</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">logging</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> };</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 错误处理选项</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">constexpr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Error_action default_Error_action </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Error_action::throwing;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 默认选项</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">enum</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Error_code</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> { </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">range_error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">length_error</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> };</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 单独的错误类型</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">string error_code_name[] { </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;range error&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;length error&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> };</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">// 单独错误的名称</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">template</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">Error_action</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> action</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> =</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> default_Error_action, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">class</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> C</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">constexpr</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> expect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">C</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> cond</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">Error_code</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> x</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 如果期望的条件 &quot;cond&quot; 不成立，则采取 &quot;action&quot;</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> constexpr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (action </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Error_action::logging)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cond</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()) std::cerr </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &quot;expect() failure: &quot;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39; &#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;&lt;</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> error_code_name</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(x)] </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;&lt;</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">\n</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> constexpr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (action </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Error_action::throwing)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cond</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">throw</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> x;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    if</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> constexpr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (action </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">==</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Error_action::terminating)</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        if</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">!</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">cond</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">()) std::</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">terminate</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 或不采取任何行动</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>乍一看，这可能令人困惑，因为我们尚未介绍使用的许多语言特性。但是，正如所需，它非常灵活且易于使用。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">double&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> Vector::</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">operator</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[](</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    expect</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">([</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;">i</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">this</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">] { </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">i </span><span style="--shiki-light:#A626A4;--shiki-dark:#56B6C2;">&amp;&amp;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> i</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&lt;</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">size</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(); }, Error_code::range_error);</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;"> elem</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">[i];</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这会检查下标是否在范围内，如果不满足则采取默认行动，即抛出异常。预期成立的条件 <strong>0&lt;=i&amp;&amp;i&lt;size()</strong> 作为 lambda 表达式 <strong>[i,this]{return 0&lt;=i&amp;&amp;i&lt;size();}</strong> 传递给 <strong>expect()</strong> （§ 7.3.3）。 <strong>if constexpr</strong> 测试在编译时完成（§ 7.4.3），因此对于 <strong>expect()</strong> 的每一次调用，最多只执行一次运行时测试。将 <strong>action</strong> 设置为 <strong>Error_action::ignore</strong> ，则不采取任何行动，也不为 <strong>expect()</strong> 生成代码。</p><p>通过设置 <strong>default_Error_action</strong> ，用户可以根据程序的具体部署选择合适的行动，比如终止或记录日志。为了支持记录日志，需要定义一个 <strong>error_code_names</strong> 表。记录信息可以通过使用 <strong>source_location</strong> （§ 16.5）进一步改进。</p><p>在许多系统中，断言机制（如 <strong>expect()</strong> ）提供了一个控制断言失败含义的单一控制点是非常重要的。在大型代码库中搜索时，实际上是在检查假设的 <strong>if</strong> 语句，通常是不切实际的。</p><h3 id="_4-5-1-assert-函数" tabindex="-1"><a class="header-anchor" href="#_4-5-1-assert-函数"><span>4.5.1 assert() 函数</span></a></h3><p>标准库提供了调试宏 <strong>assert()</strong> ，用于断言某个条件在运行时必须成立。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">const</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> char*</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> p</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(p </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> nullptr</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 确保 p 不是空指针</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 <strong>assert()</strong> 中的条件在“调试模式”下失败，程序将终止。如果不是调试模式，则不会检查 <strong>assert()</strong> 。这种方法相当原始且不够灵活，但通常总比没有任何检查要好。</p><p><strong>assert()</strong> 的主要限制在于它依赖于编译器的预处理器定义。通常，当编译器以非调试模式（如 <strong>-O2</strong> 优化级别）构建程序时，所有 <strong>assert()</strong> 调用都会被移除，从而不会在生产环境中执行任何检查。这意味着无法在部署后动态调整断言行为，也无法获取断言失败的详细信息，除非有专门的日志记录机制或使用更复杂的自定义断言函数，如前面提到的 <strong>expect()</strong> 示例所示。</p><p>此外， <strong>assert()</strong> 主要用于开发者发现逻辑错误，确保内部程序状态符合预期，而不应该作为处理用户输入错误或外部系统故障的主要机制。在发布的产品代码中，更倾向于采用更细致的错误处理策略，如异常处理、错误码返回或者日志记录等。</p><h3 id="_4-5-2-静态断言" tabindex="-1"><a class="header-anchor" href="#_4-5-2-静态断言"><span>4.5.2 静态断言</span></a></h3><p>异常用于报告运行时发现的错误。如果错误能在编译时发现，通常更倾向于这样做。这就是类型系统和为用户自定义类型指定接口的设施存在的目的。然而，我们也可以对大多数编译时已知的属性执行简单检查，并将不符合预期的情况作为编译器错误消息报告。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static_assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &lt;=</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">), </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;integers are too small&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 检查整数大小</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果 <strong>4 &lt;= sizeof(int)</strong> 不成立，即在这个系统中 <strong>int</strong> 类型的大小不足 4 字节，这将输出 &quot;integers are too small&quot;。我们称这样的期望声明为 <strong>静态断言</strong> 。</p><p>静态断言机制可用于任何可以用常量表达式（§ 1.6）表达的事物。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">constexpr</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> double</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> C </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 299792458</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 光速，单位 m/s</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> f</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">double</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> speed</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    constexpr</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> double</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> local_max </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 160.0</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1000</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> /</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">60</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> *</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 60</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 160 km/h 转换为 m/s</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static_assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(speed </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> C, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;can&#39;t go that fast&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 如果速度大于光速则报错</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    static_assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(local_max </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">&gt;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> C, </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;can&#39;t go that fast&quot;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 同上，但此处是常量表达式，故合法</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>一般来说， <strong>static_assert(A, S)</strong> 如果 <strong>A</strong> 不为真，则将 <strong>S</strong> 打印为编译器错误消息。如果你不想打印特定的消息，可以省略 <strong>S</strong> ，编译器会提供一个默认消息：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">static_assert</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">4</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> &gt;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> sizeof</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">));</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 使用默认消息</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>默认消息通常是静态断言的源位置加上断言谓词的字符表示。</p><p>静态断言的一个重要用途是在泛型编程（§ 8.2、§ 16.4）中对作为参数使用的类型进行断言。这允许在编译时验证模板参数是否满足特定条件，从而避免了运行时错误，并提高了代码的健壮性和类型安全。</p><h3 id="_4-5-3-noexcept" tabindex="-1"><a class="header-anchor" href="#_4-5-3-noexcept"><span>4.5.3 noexcept</span></a></h3><p>声明永不抛出异常的函数可以使用 <strong>noexcept</strong> 标识。例如：</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">void</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> user</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-light-font-style:inherit;--shiki-dark:#E06C75;--shiki-dark-font-style:italic;"> sz</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">noexcept</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">{</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">    Vector </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(sz);</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">    iota</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">begin</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#E45649;--shiki-dark:#E5C07B;">v</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">end</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(), </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"> // 从1开始递增填充 v（§ 17.3）</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果所有良好的意图和规划都失败了，以至于 <strong>user()</strong> 仍然抛出了异常，那么将调用 <strong>std::terminate()</strong> 立即终止程序。</p><p>不加思考地在函数上随意使用 <strong>noexcept</strong> 是危险的。如果一个标记了 <strong>noexcept</strong> 的函数调用了另一个抛出异常的函数，并期望该异常会被捕获并处理，那么 <strong>noexcept</strong> 会将这种情况转变为致命错误。此外， <strong>noexcept</strong> 迫使编写者通过某种形式的错误码来处理错误，这可能会很复杂、容易出错且成本较高（§ 4.4）。像其他强大的语言特性一样， <strong>noexcept</strong> 应当在充分理解并谨慎的情况下使用。</p><h2 id="_4-6-建议" tabindex="-1"><a class="header-anchor" href="#_4-6-建议"><span>4.6 建议</span></a></h2><ol><li>当无法完成指定任务时，抛出异常； §4.4；[CG: E.2]。</li><li>仅在错误处理时使用异常； §4.4；[CG: E.3]。</li><li>未能打开文件或未到达迭代结束是预期事件，而非异常情况； §4.4。</li><li>当期望立即调用者处理错误时，使用错误码； §4.4。</li><li>对于预期会渗透多层函数调用的错误，抛出异常； §4.4。</li><li>如果对使用异常还是错误码有疑问，优先选择异常； §4.4。</li><li>在设计初期制定错误处理策略； §4.4；[CG: E.12]。</li><li>使用专门设计的用户自定义类型作为异常（而非内置类型）； §4.2。</li><li>不要尝试在每个函数中捕获所有异常； §4.4；[CG: E.7]。</li><li>不必使用标准库的异常类层次结构； §4.3。</li><li>优先使用RAII而非显式的 <strong>try</strong> 块； §4.2, §4.3；[CG: E.6]。</li><li>让构造函数建立不变性，并在无法建立时抛出异常； §4.3；[CG: E.5]。</li><li>围绕不变性设计你的错误处理策略； §4.3；[CG: E.4]。</li><li>能在编译时检查的通常最好在编译时检查； §4.5.2 [CG: P.4] [CG: P.5]。</li><li>使用断言机制为失败的意义提供单一控制点； §4.5。</li><li>概念（ §8.2）是编译时谓词，因此在断言中很有用； §4.5.2。</li><li>如果你的函数可能不抛出异常，声明它为 <strong>noexcept</strong> ； §4.4；[CG: E.12]。</li><li>不要不加思索地应用 <strong>noexcept</strong> ； §4.5.3。</li></ol></div><!----><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><span class="vp-meta-info" data-allow-mismatch="text">2024/11/8 04:35:03</span></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: nfzwy@南风">nfzwy</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/cpp/chapter03/" aria-label="第3章 模块化"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><!---->第3章 模块化</div></a><a class="route-link auto-link next" href="/cpp/chapter05/" aria-label="第5章 类"><div class="hint">下一页<span class="arrow end"></span></div><div class="link">第5章 类<!----></div></a></nav><div id="comment" class="giscus-wrapper input-top vp-comment" vp-comment style="display:block;"><div class="loading-icon-wrapper" style="display:flex;align-items:center;justify-content:center;height:96px"><svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" preserveAspectRatio="xMidYMid" viewBox="25 25 50 50"><animateTransform attributeName="transform" type="rotate" dur="2s" keyTimes="0;1" repeatCount="indefinite" values="0;360"></animateTransform><circle cx="50" cy="50" r="20" fill="none" stroke="currentColor" stroke-width="4" stroke-linecap="round"><animate attributeName="stroke-dasharray" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="1,200;90,200;1,200"></animate><animate attributeName="stroke-dashoffset" dur="1.5s" keyTimes="0;0.5;1" repeatCount="indefinite" values="0;-35px;-125px"></animate></circle></svg></div></div><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper" vp-footer><div class="vp-footer">默认页脚</div><div class="vp-copyright">Copyright © 2024 南风 </div></footer></div><!--]--><!--]--><!--[--><!----><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-tSwHPRi-.js" defer></script>
  </body>
</html>
